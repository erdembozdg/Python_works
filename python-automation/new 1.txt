import os
from abc import ABCMeta, abstractmethod
import io
import time
import math
import weakref
from functools import total_ordering


class Node():
    def __init__(self, value):
        self._value = value
        self._children = []
        self._parent = None

    @property
    def parent(self):
        return self._parent

    @parent.setter
    def parent(self, value):
        self._parent = weakref.ref(value)

    def __repr__(self):
        return 'Node({})'.format(self._value)

    def add_children(self, node):
        self._children.append(node)
        node.parent = self

    def __iter__(self):
        return iter(self._children)
    
    def depth_first(self):
        yield self
        for c in self:
            yield from c.depth_first()

print("----------------")

_formats = {
    'ymd' : '{d.year}-{d.month}-{d.day}',
    'mdy' : '{d.month}/{d.day}/{d.year}'
}

class Date:
    __slots__ = ['year', 'month', 'day']
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day

    # Alternate constructor
    @classmethod
    def today(cls):
        t = time.localtime()
        return cls(t.tm_year, t.tm_mon, t.tm_mday)
    
    def __format__(self, code):
        if code == "":
            code = 'ymd'
        fmt = _formats[code]
        return fmt.format(d=self)

def func():
    return "datacamp"


print("----------------")
# Descriptors
class Integer:
    def __init__(self, name):
        self.name = name
    
    def __get__(self, instance, cls):
        if instance is None:
            instance = self
        else:
            return instance.__dict__[self.name]

    def __set__(self, instance, value):
        if not isinstance(value, int):
            raise TypeError('Expected ')
        instance.__dict__[self.name] = value


    def __delete__(self, instance):
        del instance.__dict__[self.name]

print("----------------")

class Structure:
    _fields = []
    def __init__(self, *args, **kwargs):
        if len(self._fields) != len(args):
            raise TypeError('Expected {} arguments'.format(len(self._fields)))

        for name, value in zip(self._fields, args):
            setattr(self, name, value)

        extra_args = kwargs.keys() - self._fields
        for name in extra_args:
            setattr(self, name, kwargs.pop(name))

class SubStructure(Structure):
    _fields = ['x','y']

print("----------------")

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return 'Point({} {})'.format(self.x, self.y)
    
    def distance(self, x, y):
        return math.hypot(self.x - x, self.y - y)

print("----------------")

class Room:
    def __init__(self, name, length, width):
        self.name = name
        self.length = length
        self.width = width
        self.square_feet = self.width * self.length

@total_ordering
class House:
    def __init__(self, name, style):
        self.name = name
        self.style = style
        self.rooms = list()

    def add_room(self, room):
        self.rooms.append(room)

    def living_space(self):
        return sum(r.square_feet for r in self.rooms)
    
    def __str__(self):
        return '{}: {} square foot {}'.format(self.name,
                                              self.living_space,
                                              self.style)
    def __eq__(self, other):
        return self.living_space == other.living_space

    def __lt__(self, other):
        return self.living_space < other.living_space 
        
print("----------------")

if __name__ == '__main__':
    
    root = Node(12)
    child_1 = Node(111)
    child_2 = Node(222)
    root.add_children(child_2)
    root.add_children(child_1)
    child_1.add_children(Node(44))
    child_2.add_children(Node(440))

    for r in root.depth_first():
        print(r)

    print(child_1.parent)
    del root
    print(child_1.parent)

    d = Date(2019, 12, 120)
    d2 = Date.today()
    print(format(d, 'mdy'))
    print(format(d2))
    print('{:mdy}'.format(d))

    p = SubStructure(2,3, n = "erdem")
    print(p.x, p.y, p.n)

    p = Point(2, 3)
    print(getattr(p, 'distance')(0,0))


class Connection:
    def __init__(self):
        self.new_state(ClosedConnectionState)

    def new_state(self, newstate):
        self._state = newstate

    def read(self):
        return self._state.read(self)
    
    def write(self, data):
        return self._state.write(self, data)

    def open(self):
        return self._state.open(self)

    def close(self):
        return self._state.close(self)

class ConnectionState:

    @staticmethod
    def read(conn):
        raise NotImplementedError()

    @staticmethod
    def write(conn, data):
        raise NotImplementedError()

    @staticmethod
    def open(conn):
        raise NotImplementedError()

    @staticmethod
    def close(conn):
        raise NotImplementedError()   

class ClosedConnectionState(ConnectionState):

    @staticmethod
    def read(conn):
        raise RuntimeError('Not Open')
    
    @staticmethod
    def write(conn, data):
        raise RuntimeError('Not Open')

    @staticmethod
    def open(conn):
        return conn.new_state(OpenConnectionState) 

    @staticmethod
    def close(conn):
        raise NotImplementedError() 

class OpenConnectionState(ConnectionState):

    def read(conn):
        print("reading")
    
    def write(conn, data):
        print("writing")

    def open(conn):
        raise RuntimeError('Already Open')

    def close(conn):
        return conn.new_state(ClosedConnectionState)

print("----------------")
# Inheritance
class Connection2:
    def __init__(self):
        self.new_state(ClosedConnection)

    def new_state(self, newstate):
        self.__class__ = newstate

    def read(self):
        raise NotImplementedError()
    
    def write(self, data):
        raise NotImplementedError()

    def open(self):
        raise NotImplementedError()

    def close(self):
        raise NotImplementedError()

class ClosedConnection(Connection2):

    def read(conn):
        raise RuntimeError('Not Open')
    
    def write(conn, data):
        raise RuntimeError('Not Open')

    def open(conn):
        return conn.new_state(OpenConnection) 

    def close(conn):
        raise NotImplementedError() 

class OpenConnection(Connection2):

    def read(conn):
        print("reading")
    
    def write(conn, data):
        print("writing")

    def open(conn):
        raise RuntimeError('Already Open')

    def close(conn):
        return conn.new_state(ClosedConnection)

c = Connection()
c._state
c.open()
c.read()

c = Connection2()
c.open()
c.read()


import abc

class BaseFile:
    def __init__(self, filename):
        if not filename.endswith(self.ext):
            raise Exception("Invalid File Format")
        self.filename = filename

class X(BaseFile):
    ext = 'x'
    def play(self):
        print('Playing {} as X'.format(self.filename))


class Y(BaseFile):
    ext = 'y'
    def play(self):
        print('Playing {} as Y'.format(self.filename))

x = X('aaa.x')
x.play()

class Loader(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def play(self):
        pass

    @abc.abstractproperty
    def ext(self):
        pass

    @classmethod
    def __subclasshook__(cls, C):
        if cls is Loader:
            attrs = set(dir(C))
            if set(cls.__abstractmethods__) <= attrs:
                return True
        
        return NotImplemented

class SubLoader:
    ext = '.x'
    def play(self):
        print('This will play')

print(isinstance(SubLoader(), Loader))


import csv
from collections import namedtuple
import re
import json
from urllib.request import urlopen
from xml.etree.ElementTree import parse, Element, tostring
import sqlite3
import binascii
import base64
from struct import Struct

# CSV Data 
with open('stocks.csv') as f:
    f_csv = csv.reader(f)
    try:
        header = next(f_csv)
        Row = namedtuple('Row', header)
    except ValueError:
        header = (re.sub('[^a-zA-Z_]', '_', n) for n in next(f_csv))
        Row = namedtuple('Row', header)
    for r in f_csv:
        row = Row(*r)
        print(f'Symbol: {row.Symbol}, Volume: {row.Volume}')

print("----------------")
# Json Data
data = {
    'name' : 'xxx',
    'shares' : 22,
    'price' : 33.3
}

s = json.dumps(data)
print(json.loads(s))
with open('data.json', 'w') as f:
    json.dump(data, f, indent=4)
with open('data.json', 'r') as f:
    print(json.load(f))
print("----------------")

# XML Data
u = urlopen("https://planetpython.org/rss20.xml")
doc = parse(u)

for item in doc.iterfind("channel/item"):
    title = item.findtext('title')
    date = item.findtext('pubDate')
    link = item.findtext('link')

root = doc.getroot()
e = Element('spam')
e.text = 'This is a test'
root.insert(2, e)

doc.write('newpred.xml', xml_declaration=True)

doc = parse('newpred.xml')

print("----------------")
# From a dic to XML

def dic_to_xml(parent, d):
    elem = Element(parent)
    for key, val in d.items():
        child = Element(key)
        child.text = str(val)
        elem.append(child)
    return elem

dic = { 'name' : 'erdem', 'role': 'engineer' }
e = dic_to_xml('employee', dic)
e.set('id', '0')
print(tostring(e))

print("----------------")
# Implementing sqlite3
stocks = [
    ('GOOG', 100, 490.1),
    ('AAPL', 50, 545.75),
    ('FB', 150, 7.45),
    ('HPQ', 75, 33.2),
]
db = sqlite3.connect('database.db')
c = db.cursor()
try:
    c.execute('create table data (symbol text, shares integer, price real)')
    db.commit()
    c.executemany('insert into data values (?,?,?)', stocks)
    db.commit()
except:
    pass

min_price = 100
for row in db.execute('select * from data where price >= ?', (min_price,)):
    print(row)

print("----------------")
# Encoding hex, base64
s = b'hello'
h = binascii.b2a_hex(s)
print(h)
print(binascii.a2b_hex(h))
h = base64.b16encode(s)
print(base64.b16decode(h))

print("----------------")
# Binary Data
def write_records(records, format, f):
    record_struct = Struct(format)
    for r in records:
        f.write(record_struct.pack(*r))

def read_records(format, f):
    record_struct = Struct(format)
    chunks = iter(lambda: f.read(record_struct.size), b'')
    return (record_struct.unpack(chunk) for chunk in chunks)

if __name__ == '__main__':
    records = [ (1, 2.3, 4.5),
                (6, 7.8, 9.0),
                (12, 13.4, 56.7) ]

    with open('data.b', 'wb') as f:
        write_records(records, '<idd', f)
    
    with open('data.b', 'rb') as f:
        for rec in read_records('<idd', f):
            print(rec)


from urllib.request import urlopen
import time
import sys
import shutil
import zipfile
from pathlib import Path

class Color:
    def __init__(self, name, value):
        self._name = name
        self._value = value

    def _set_name(self, name):
        if not name:
            raise Exception('Invalid name')
        self._name = name

    def _get_name(self):
        return self._name

    def _del_name(self):
        del self._name

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, value):
        if not value:
            raise Exception('Invalid value')
        self._value = value

    @value.deleter
    def value(self):
        del self._value

    name = property(_get_name, _set_name, _del_name, 'This is a property')

class AverageList(list):
    @property
    def average(self):
        return sum(self) / len(self)

class WebPage():
    def __init__(self, url):
        self.url = url
        self._content = None

    @property
    def content(self):
        if self._content is None:
            self._content = urlopen(self.url).read()
        return self._content

a = AverageList([1, 56, 22])
print(a.average)

c = Color('e', 'c')
c.name = 'erdem'


from io import StringIO
from io import TextIOWrapper
import gzip
import bz2
from functools import partial
import os
from fnmatch import fnmatch
import glob
import urllib.request
import sys
from tempfile import NamedTemporaryFile, TemporaryDirectory
import pickle

dirpath = os.getcwd()
filename = "data.txt"
path = os.path.join(dirpath, filename)
os.chmod(path, 0o777)

with open('data.txt', 'rt', encoding='latin-1') as f:
    data = f.read()
    print(data)
    # for line in f:

with open('write_data.txt', 'wt') as f:
    f.write('text1.txt\n')
    print("xxxx", file=f, end='!!\n')

row = ('xyz', 33)
print(*row)
print(' '.join(str(x) for x in row))
print("----------------")

with open('xyz.bin', 'wb') as f:
    text = 'Hello '
    f.write(text.encode('utf-8'))
    f.write(b'Erdem')

with open('xyz.bin', 'rb') as f:
    data = f.read(16)
    text = data.decode('utf-8')
    print(text)

print("----------------")

s = StringIO()
s.write('Test: ')
print('file-like object example', file=s)
print(s.read())
print("----------------")

with gzip.open('data.gz', 'wt') as f:
    f.write('test gzip')

with bz2.open('data.bz2', 'wt') as f:
    f.write('test gzip')

with gzip.open('data.gz', 'rt') as f:
    print(f.read())

with bz2.open('data.bz2', 'rt') as f:
    print(f.read())
print("----------------")

RECORD_SIZE = 32
with open('xyz.bin', 'rb') as f:
    records = iter(partial(f.read, RECORD_SIZE), b'')
    for record in records:
        print(record)
print("----------------")
def read_into_buffer(filename):
    buf = bytearray(os.path.getsize(filename))
    with open(filename, 'rb') as f:
        return f.readinto(buf)
print(read_into_buffer('xyz.bin'))
print("----------------")

print(os.path.basename(path))
print(os.path.dirname(path))
print(os.path.join('tmp', 'data', os.path.basename(path)))
print(os.path.expanduser(path))
print(os.path.splitext(path))
print(os.path.isfile(path))
print(os.path.isdir(path))
print(os.path.exists(path))
print(os.path.islink(path))
print(os.path.realpath(path))
print(os.path.getsize(path))
print(os.path.getmtime(path))

print("----------------")

names = [name for name in os.listdir(os.path.dirname(path))]
for name in names:
    if os.path.isfile(name):
        print(f'{name} is file')
    if os.path.isdir(name):
        print(f'{name} is directory')
    if name.endswith('.py'):
        print(f'{name} is python file')
    if fnmatch(name, '*.py'):
        print(f'{name} is python file')

print("----------------")

pyfiles = glob.glob('*.py')
names = [(name, os.path.getsize(name), os.path.getmtime(name)) for name in pyfiles]
for name, size, time in names:
    print(name, size, time)

names = [(name, os.stat(name)) for name in pyfiles]
for name, metadata in names:
    print(name, metadata.st_size, metadata.st_mtime)

print("----------------")

u = urllib.request.urlopen('http://www.python.org')
f = TextIOWrapper(u, encoding='utf-8')

print(sys.stdout.encoding)
sys.stdout = TextIOWrapper(sys.stdout.detach(), encoding='latin-1')
print(sys.stdout.encoding)
sys.stdout.buffer.write(b'Hello Erdem')

print("----------------")

with NamedTemporaryFile('w+t') as f:
    f.write('Hello World\n')
    f.write('Erdem')

    f.seek(0)
    print(f"file names is {f.name}\n{f.read()}")

with TemporaryDirectory() as dirname:
    print(dirname)

print("----------------")

data = object()
f = open(filename, 'wb')
pickle.dump(data, f)
s = pickle.dumps(data)

f = open(filename, 'rb')
data = pickle.load(f)
data = pickle.loads(s)



from abc import ABCMeta, abstractmethod
import operator
from contextlib import contextmanager

class NoInstance(type):
    def __call__(self, *args, **kwargs):
        raise TypeError('Cannot instantiate directly')

class Singleton(type):
    def __init__(self, *args, **kwargs):
        self.__instance = None
        super().__init__(*args, **kwargs)

    def __call__(self, *args, **kwargs):
        if self.__instance is None:
            self.__instance = super().__call__(*args, **kwargs)
            return self.__instance
        else:
            return self.__instance

class test1(metaclass=NoInstance):
    @staticmethod
    def grok():
        print('No instance')


class test2(metaclass=Singleton):
    def __init__(self):
        print('Creating Singleton pattern')

print("----------------")
class IStream(metaclass=ABCMeta):
    @abstractmethod
    def read(self, maxsize=None):
        pass

    @abstractmethod
    def write(self, data):
        pass

print("----------------")
# Extend Metadata
class MyMeta(type):
    def __new__(cls, clsname, bases, clsdict, *, debug=False, synchronize=False):
        for name in clsdict:
            if name.lower() != name:
                raise TypeError('Bad attribute name', name)
        return super().__new__(cls, clsname, bases, clsdict)

    def __init__(self, clsname, bases, ns, *, debug=False, synchronize=False):
        return super().__init__(clsname, bases, ns)

class Root(metaclass=MyMeta, debug=True, synchronize=True):
    pass

class child(Root):
    def foobar(self):
        pass

print("----------------")

class StructTupleMeta(type):
    def __init__(cls, *args, **kwargs):
        super().__init__(*args, **kwargs)
        for n, name in enumerate(cls._fields):
            setattr(cls, name, property(operator.itemgetter(n)))

class StructTuple(tuple, metaclass=StructTupleMeta):
    _fields = []
    def __new__(cls, *args):
        if len(args) != len(cls._fields):
            raise TypeError('{} arguments required'.format(len(cls._fields)))
        return super().__new__(cls, args)

class Stock(StructTuple):
    _fields = ['name', 'shares', 'price']

print("----------------")

def type_property(name, expected_type):
    _name = '_' + name

    @property
    def prop(self):
        return getattr(self, __name)

    def prop(self, value):
        if not isinstance(value, expected_type):
            raise TypeError('{}  must be a {}'.format(name, expected_type))
        setattr(self, _name, value)
    
    return prop

class Person:
    name = type_property('name', str)
    age = type_property('age', int)
    def __init__(self, name, age):
        self.name = name
        self.age = age

print("----------------")
# Context Manager

@contextmanager
def list_transaction(items):
    li = list(items)
    yield li
    items[:] = li

print("----------------")

def test3():
    a = 10
    loc = locals()
    exec('b = a + 3')
    b = loc['b']
    print(b)



test1.grok()
x1 = test2()
x2 = test2()
print(x1 is x2)
s = Stock('xxx', 33, 2.3)
print(s[1])

items = [1, 2, 3]
with list_transaction(items) as l:
    l.append(4)

print(items)

test3()
exec('for i in range(10): print(i, end=\'\')')


'''
@property methods should be light, do slow or complex work using normal methods
'''
class Resistor:
    def __init__(self, ohms):
        self.ohms = ohms
        self.voltage = 0
        self.current = 0

class VoltageResistance(Resistor):
    def __init__(self, ohms):
        super().__init__(ohms)
        self._voltage = 0

    @property
    def voltage(self):
        return self._voltage

    @voltage.setter
    def voltage(self, voltage):
        self._voltage = voltage
        self.current = self._voltage / self.ohms

class BoundedResistance(Resistor):
    def __init__(self, ohms):
        super().__init__(ohms)

    @property
    def ohms(self):
        return self._ohms

    @ohms.setter
    def ohms(self, ohms):
        if ohms < 0:
            raise ValueError('%f must be > 0' % ohms)
        if hasattr(self, '_ohms'):
            raise AttributeError('Cannot set attribute')
        self._ohms = ohms

r1 = VoltageResistance(1e3)
r2 = BoundedResistance(1e3)
r1.voltage = 10
r2.ohms = 10
print('%5r amps and %1f' % (r1.current, r2.current))



'''
Descriptor Classes
'''
import weakref

class Grade:
    def __init__(self):
        self._values = weakref.WeakKeyDictionary()
    def __get__(self, instance, instance_type):
        if instance is None: return self
        return self._values.get(instance, 0)
    def __set__(self, instance, value):
        if not (0 <= value <= 100):
            raise ValueError("Grade must be between 0 and 100")
        self._values[instance] = value

class Exam():
    writing_grade = Grade()

exam1  = Exam()
exam1.writing_grade = 82
exam2  = Exam()
exam2.writing_grade = 82
assert exam1.writing_grade == exam2.writing_grade


'''
'__getattr__' is useful for use cases like lazily accessing schemales data, which is only called for missing attributes.
'__getattribute__' and '__setattr__' are called every time an attribute is accessed on an object.
'''
class LazyDB:
    def __init__(self):
        self.exists = 5

    def __getattr__(self, name):
        value = 'Value for %s is missing' % name
        setattr(self, name, value)
        return value

class LoggingDB1(LazyDB):
    def __getattr__(self, name):
        print('Called __getattr__(%s)' % name)
        return super().__getattr__(name)

    def __setattr__(self, name, value):
        print('Called __setattr__(%s, %s)' % (name, value))
        return super().__setattr__(name, value)

class LoggingDB2(LazyDB):
    def __getattribute__(self, name):
        print('Called __getattribute__(%s)' % name)
        try:
            return super().__getattribute__(name)
        except AttributeError:
            print('Called __getattr__(%s)' % name)
            return super().__getattr__(name)


data1 = LoggingDB1()
data2 = LoggingDB2()
data1.exists = 10
print(data1.foo)
print(f'exists: {data1.exists}')
print(data2.foo)
print(f'exists: {data2.exists}')



class MyBaseClass():
    def __init__(self, value):
        self.value = value

class Explicit(MyBaseClass):
    def __init__(self, value):
        super(__class__, self).__init__(value * 2)

class Implicit(MyBaseClass):
    def __init__(self, value):
        super().__init__(value * 2)

assert Explicit(5).value == Implicit(5).value

# Only consider using private attributes to avoid naming conflicts with subclasses.
class MyObject:
    def __init__(self):
        self.public_field = 5
        self.__private_field = 10

    def get_private_field(self):
        return self.__private_field

    @classmethod
    def get_private_field_of_instance(cls, instance):
        return instance.__private_field

class MyChildObject(MyObject):
    def __init__(self):
        super().__init__()
        self._private_field = 11

foo = MyObject()
baz = MyChildObject()
print(foo.public_field)
assert MyObject.get_private_field_of_instance(foo) == foo.get_private_field()
assert baz._MyObject__private_field == 10
assert baz._private_field != baz.get_private_field()


class flist(list):
    def __init__(self, li):
        super().__init__(li)

    def frequency(self):
        counts = {}
        for item in self:
            counts.setdefault(item, 0)
            counts[item] += 1
        return counts

li = flist([1, 2, 3])
li.pop()
print(li.frequency())



def divide(x, y):
    try:
        return x / y
    except ZeroDivisionError as e:
        raise ValueError('Input errors') from e

try:
    result = divide(2, 0)
except ValueError:
    print('Input errors')
else:
    print('Result: %.1f' % result)


def sort_priority(values, group):
    found = False
    def helper(x):
        nonlocal found
        if x in group:
            found = True
            return (0, x)
        return (1, x)
    values.sort(key=helper)
    return found

values = [8, 3, 1, 2, 5, 4, 7, 6]
group = {3, 6, 8, 2}
result = sort_priority(values, group)
print(values, result)

class Sort(object):
    def __init__(self, group):
        self.group = group
        self.found = False

    def __call__(self, x):
        if x in self.group:
            self.found = True
            return (0, x)
        return (1, x)

sorter = Sort(group)
values.sort(key=sorter)
print(values)
assert sorter.found is True


from itertools import islice
def index_word(f):
    offset = 0
    for line in f:
        if line:
            yield offset
        for index, letter in enumerate(line):
            offset +=1
            if letter == ' ':
                yield offset

with open('python-cookbook/files/data.txt', 'r') as f:
    it = index_word(f)
    result = islice(it, 3, 4)
    print(list(result))

import time, datetime
def normalize(get_iter):
    total = sum(get_iter())
    result = []
    for value in get_iter():
        percentage = 100 * value / total
        result.append(percentage)
    return result
print(normalize(lambda: values))


import json
def decode(data, default=None, when=None, ignore=False):
    if default == None:
        default = {}
    when = datetime.datetime.now() if when is None else when
    try:
        print("%s %s" % (json.loads(data), when))
    except ValueError:
        if ignore:
            return 0
        print("%s %s" % (default, when))
decode("Hello World", ignore = True)



def to_str(byte_or_str):
    if isinstance(byte_or_str, bytes):
        value = byte_or_str.decode('utf-8')
    else:
        value = byte_or_str
    return value

def to_byte(byte_or_str):
    if isinstance(byte_or_str, str):
        value = byte_or_str.encode('utf-8')
    else:
        value = byte_or_str
    return value


def test(values, key):
    found = values.get(key, [2,3,4])
    return found
print(test({'a':1,"b":4}, 'c'))


a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
assert a[:4] == a[0:4]
assert a[-4:] == a[-4:len(a)]
print(a[::-1])
print(a[-2:2:-2])
print(a[-100:100])
b = a[:]
assert b == a and b is not a
b = a
assert b == a and b is a 
a = [1, 2, 3]
assert b != a and b is not a 

for k,v in enumerate(a):
    print('%d: %s\t' % (k, v), end= '')
print()


li1 = [i for i in range(20) if int(i) % 2 == 0]
li2 = list(map(lambda i: i, filter(lambda x: x % 2 == 0, range(20))))
assert li1 == li2
dic = {'Erdem': 1, 'Bozdag': 2}
print({value: key for key, value in dic.items()})
print({len(key) for key in dic.keys()})


matrix = [[1, 2], [3, 4], [5, 6]]
flat = []
flat.extend(i for row in matrix if sum(row) > 3 for i in row if i > 3)
print(flat)
print([[i for i in row if i > 3] for row in matrix if sum(row) > 3])


it = ((str(x), len(x)) for x in open('python-cookbook/files/data.txt'))
print(next(it))


names = ['Cecilla', 'Lise', 'Marie']
letters = [len(name) for name in names]
longest_name = None
max_letter = 0

for name, count in zip(names, letters):
    if count > max_letter:
        max_letter = count
        longest_name = name
print(longest_name)


def else_block(first, last):
    for i in range(first, last):
        print("%d " % i, end='')
        if i == 100:
            break
    else:
        first = last
        last += 10
        else_block(first, last)
        
else_block(1, 10)


import json
def update_file(path):
    handler = open(path, 'r+')
    try:
        data = handler.read()
        ob = json.loads(data)
    except Exception as e:
        return False
    else:
        result = json.dumps(ob)
        handler.seek(0)
        handler.write(result)
        return True
    finally:
        handler.close()    

update_file('python-cookbook/files/data.txt')


from collections import namedtuple
import collections
'''
Avoid manking dictionaries with values that are other dictionaries or long tuples.
'''
class SimpleGradeBook:
    def __init__(self):
        self._grades = {}

    def add_student(self, name):
        self._grades[name] = {}

    def report_grade(self, name, subject, score, weight, comment):
        by_subject = self._grades[name]
        grade_list = by_subject.setdefault(subject, [])
        grade_list.append((score, weight, comment))

    def average_grade(self, name):
        by_subject = self._grades[name]
        for subject, grades in by_subject.items():
            total, total_weight = 0, 0
            total = sum(score * weight for score, weight, _ in grades)
            total_weight = sum(weight for _, weight, _ in grades)
            yield (subject, total/total_weight)

grade = SimpleGradeBook()
grade.add_student("erdem")
grade.report_grade("erdem", "math", 83, 0.3, "Good")
grade.report_grade("erdem", "math", 93, 0.7, "Great")
print(list(grade.average_grade("erdem")))

'''
Multiple helper classes when your internal state dictionaries get complicated
'''
Grade = collections.namedtuple('Grade', ('score', 'weight', 'comment'))

class Subject:
    def __init__(self):
        self._grades = []

    def report_grade(self, score, weight, comment):
         self._grades.append(Grade(score, weight, comment))

    def average_grade(self):
        total, total_weight = 0, 0
        for grade in self._grades:
            total += grade.score * grade.weight
            total_weight += grade.weight
        return total / total_weight

class Student:
    def __init__(self):
        self._subjects = {}

    def subject(self, name):
        if name not in self._subjects:
            self._subjects[name] = Subject()
        return self._subjects[name]

    def average_grade(self):
        total, count = 0, 0
        for subject in self._subjects.values():
            total += subject.average_grade()
            count += 1
        return total / count

class GradeBook:
    def __init__(self):
        self._students = {}

    def student(self, name):
        if name not in self._students:
            self._students[name] = Student()
        return self._students[name] 

book = GradeBook()
erdem = book.student("erdem")
math = erdem.subject("Math")
math.report_grade(83, 0.3, "Good")
math.report_grade(93, 0.7, "Great")
print(erdem.average_grade())


from collections import defaultdict

m1 = {'x': 1, 'y': 2}
l1 = [ ('a', 3), ('b', 4) ]

#  a stateful closure.
def combine(m1, l1):
    count = 0
    def log():
        nonlocal count
        count += 1
        return 0
    d1 = defaultdict(log, m1)
    for key, value in l1:
        d1[key] += value
    return count
assert combine(m1, l1) == 2

# Using a helper class is a better solution than
class logging:
    def __init__(self):
        self.count = 0
    def __call__(self):
        self.count +ou= 1
        return 0

log = logging()
assert callable(log)

d1 = defaultdict(log, m1)
for key, value in l1:
    d1[key] += value
assert log.count == 2


import pickle

class GameState:
    def __init__(self, level = 0, lives = 4):
        self.level = level
        self.lives = lives
        
state = GameState()
state.level = 0
state.lives = 4

file = "game_state.bin"
with open(file, "wb") as f:
    pickle.dump(state, f)
with open(file, "rb") as f:
    state_after = pickle.loads(f.read())
print(state_after.__dict__)

assert isinstance(state_after, GameState)
